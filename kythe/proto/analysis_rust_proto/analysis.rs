// This file is generated by rust-protobuf 2.28.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `kythe/proto/analysis.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_28_0;

#[derive(PartialEq,Clone,Default)]
pub struct AnalysisRequest {
    // message fields
    pub compilation: ::protobuf::SingularPtrField<CompilationUnit>,
    pub file_data_service: ::std::string::String,
    pub revision: ::std::string::String,
    pub build_id: ::std::string::String,
    pub compilation_digest: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AnalysisRequest {
    fn default() -> &'a AnalysisRequest {
        <AnalysisRequest as ::protobuf::Message>::default_instance()
    }
}

impl AnalysisRequest {
    pub fn new() -> AnalysisRequest {
        ::std::default::Default::default()
    }

    // .kythe.proto.CompilationUnit compilation = 1;


    pub fn get_compilation(&self) -> &CompilationUnit {
        self.compilation.as_ref().unwrap_or_else(|| <CompilationUnit as ::protobuf::Message>::default_instance())
    }
    pub fn clear_compilation(&mut self) {
        self.compilation.clear();
    }

    pub fn has_compilation(&self) -> bool {
        self.compilation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_compilation(&mut self, v: CompilationUnit) {
        self.compilation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_compilation(&mut self) -> &mut CompilationUnit {
        if self.compilation.is_none() {
            self.compilation.set_default();
        }
        self.compilation.as_mut().unwrap()
    }

    // Take field
    pub fn take_compilation(&mut self) -> CompilationUnit {
        self.compilation.take().unwrap_or_else(|| CompilationUnit::new())
    }

    // string file_data_service = 2;


    pub fn get_file_data_service(&self) -> &str {
        &self.file_data_service
    }
    pub fn clear_file_data_service(&mut self) {
        self.file_data_service.clear();
    }

    // Param is passed by value, moved
    pub fn set_file_data_service(&mut self, v: ::std::string::String) {
        self.file_data_service = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_data_service(&mut self) -> &mut ::std::string::String {
        &mut self.file_data_service
    }

    // Take field
    pub fn take_file_data_service(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.file_data_service, ::std::string::String::new())
    }

    // string revision = 3;


    pub fn get_revision(&self) -> &str {
        &self.revision
    }
    pub fn clear_revision(&mut self) {
        self.revision.clear();
    }

    // Param is passed by value, moved
    pub fn set_revision(&mut self, v: ::std::string::String) {
        self.revision = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_revision(&mut self) -> &mut ::std::string::String {
        &mut self.revision
    }

    // Take field
    pub fn take_revision(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.revision, ::std::string::String::new())
    }

    // string build_id = 4;


    pub fn get_build_id(&self) -> &str {
        &self.build_id
    }
    pub fn clear_build_id(&mut self) {
        self.build_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_build_id(&mut self, v: ::std::string::String) {
        self.build_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_build_id(&mut self) -> &mut ::std::string::String {
        &mut self.build_id
    }

    // Take field
    pub fn take_build_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.build_id, ::std::string::String::new())
    }

    // string compilation_digest = 5;


    pub fn get_compilation_digest(&self) -> &str {
        &self.compilation_digest
    }
    pub fn clear_compilation_digest(&mut self) {
        self.compilation_digest.clear();
    }

    // Param is passed by value, moved
    pub fn set_compilation_digest(&mut self, v: ::std::string::String) {
        self.compilation_digest = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_compilation_digest(&mut self) -> &mut ::std::string::String {
        &mut self.compilation_digest
    }

    // Take field
    pub fn take_compilation_digest(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.compilation_digest, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AnalysisRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.compilation {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.compilation)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.file_data_service)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.revision)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.build_id)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.compilation_digest)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.compilation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.file_data_service.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.file_data_service);
        }
        if !self.revision.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.revision);
        }
        if !self.build_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.build_id);
        }
        if !self.compilation_digest.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.compilation_digest);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.compilation.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.file_data_service.is_empty() {
            os.write_string(2, &self.file_data_service)?;
        }
        if !self.revision.is_empty() {
            os.write_string(3, &self.revision)?;
        }
        if !self.build_id.is_empty() {
            os.write_string(4, &self.build_id)?;
        }
        if !self.compilation_digest.is_empty() {
            os.write_string(5, &self.compilation_digest)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AnalysisRequest {
        AnalysisRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CompilationUnit>>(
                "compilation",
                |m: &AnalysisRequest| { &m.compilation },
                |m: &mut AnalysisRequest| { &mut m.compilation },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "file_data_service",
                |m: &AnalysisRequest| { &m.file_data_service },
                |m: &mut AnalysisRequest| { &mut m.file_data_service },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "revision",
                |m: &AnalysisRequest| { &m.revision },
                |m: &mut AnalysisRequest| { &mut m.revision },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "build_id",
                |m: &AnalysisRequest| { &m.build_id },
                |m: &mut AnalysisRequest| { &mut m.build_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "compilation_digest",
                |m: &AnalysisRequest| { &m.compilation_digest },
                |m: &mut AnalysisRequest| { &mut m.compilation_digest },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AnalysisRequest>(
                "AnalysisRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AnalysisRequest {
        static instance: ::protobuf::rt::LazyV2<AnalysisRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AnalysisRequest::new)
    }
}

impl ::protobuf::Clear for AnalysisRequest {
    fn clear(&mut self) {
        self.compilation.clear();
        self.file_data_service.clear();
        self.revision.clear();
        self.build_id.clear();
        self.compilation_digest.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AnalysisRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AnalysisRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AnalysisOutput {
    // message fields
    pub value: ::std::vec::Vec<u8>,
    pub final_result: ::protobuf::SingularPtrField<AnalysisResult>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AnalysisOutput {
    fn default() -> &'a AnalysisOutput {
        <AnalysisOutput as ::protobuf::Message>::default_instance()
    }
}

impl AnalysisOutput {
    pub fn new() -> AnalysisOutput {
        ::std::default::Default::default()
    }

    // bytes value = 1;


    pub fn get_value(&self) -> &[u8] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }

    // .kythe.proto.AnalysisResult final_result = 10;


    pub fn get_final_result(&self) -> &AnalysisResult {
        self.final_result.as_ref().unwrap_or_else(|| <AnalysisResult as ::protobuf::Message>::default_instance())
    }
    pub fn clear_final_result(&mut self) {
        self.final_result.clear();
    }

    pub fn has_final_result(&self) -> bool {
        self.final_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_final_result(&mut self, v: AnalysisResult) {
        self.final_result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_final_result(&mut self) -> &mut AnalysisResult {
        if self.final_result.is_none() {
            self.final_result.set_default();
        }
        self.final_result.as_mut().unwrap()
    }

    // Take field
    pub fn take_final_result(&mut self) -> AnalysisResult {
        self.final_result.take().unwrap_or_else(|| AnalysisResult::new())
    }
}

impl ::protobuf::Message for AnalysisOutput {
    fn is_initialized(&self) -> bool {
        for v in &self.final_result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.final_result)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.value);
        }
        if let Some(ref v) = self.final_result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.value.is_empty() {
            os.write_bytes(1, &self.value)?;
        }
        if let Some(ref v) = self.final_result.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AnalysisOutput {
        AnalysisOutput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "value",
                |m: &AnalysisOutput| { &m.value },
                |m: &mut AnalysisOutput| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AnalysisResult>>(
                "final_result",
                |m: &AnalysisOutput| { &m.final_result },
                |m: &mut AnalysisOutput| { &mut m.final_result },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AnalysisOutput>(
                "AnalysisOutput",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AnalysisOutput {
        static instance: ::protobuf::rt::LazyV2<AnalysisOutput> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AnalysisOutput::new)
    }
}

impl ::protobuf::Clear for AnalysisOutput {
    fn clear(&mut self) {
        self.value.clear();
        self.final_result.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AnalysisOutput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AnalysisOutput {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AnalysisResult {
    // message fields
    pub status: AnalysisResult_Status,
    pub summary: ::std::string::String,
    pub details: ::protobuf::RepeatedField<::protobuf::well_known_types::Any>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AnalysisResult {
    fn default() -> &'a AnalysisResult {
        <AnalysisResult as ::protobuf::Message>::default_instance()
    }
}

impl AnalysisResult {
    pub fn new() -> AnalysisResult {
        ::std::default::Default::default()
    }

    // .kythe.proto.AnalysisResult.Status status = 1;


    pub fn get_status(&self) -> AnalysisResult_Status {
        self.status
    }
    pub fn clear_status(&mut self) {
        self.status = AnalysisResult_Status::COMPLETE;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: AnalysisResult_Status) {
        self.status = v;
    }

    // string summary = 2;


    pub fn get_summary(&self) -> &str {
        &self.summary
    }
    pub fn clear_summary(&mut self) {
        self.summary.clear();
    }

    // Param is passed by value, moved
    pub fn set_summary(&mut self, v: ::std::string::String) {
        self.summary = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_summary(&mut self) -> &mut ::std::string::String {
        &mut self.summary
    }

    // Take field
    pub fn take_summary(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.summary, ::std::string::String::new())
    }

    // repeated .google.protobuf.Any details = 3;


    pub fn get_details(&self) -> &[::protobuf::well_known_types::Any] {
        &self.details
    }
    pub fn clear_details(&mut self) {
        self.details.clear();
    }

    // Param is passed by value, moved
    pub fn set_details(&mut self, v: ::protobuf::RepeatedField<::protobuf::well_known_types::Any>) {
        self.details = v;
    }

    // Mutable pointer to the field.
    pub fn mut_details(&mut self) -> &mut ::protobuf::RepeatedField<::protobuf::well_known_types::Any> {
        &mut self.details
    }

    // Take field
    pub fn take_details(&mut self) -> ::protobuf::RepeatedField<::protobuf::well_known_types::Any> {
        ::std::mem::replace(&mut self.details, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AnalysisResult {
    fn is_initialized(&self) -> bool {
        for v in &self.details {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.summary)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.details)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.status != AnalysisResult_Status::COMPLETE {
            my_size += ::protobuf::rt::enum_size(1, self.status);
        }
        if !self.summary.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.summary);
        }
        for value in &self.details {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.status != AnalysisResult_Status::COMPLETE {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.status))?;
        }
        if !self.summary.is_empty() {
            os.write_string(2, &self.summary)?;
        }
        for v in &self.details {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AnalysisResult {
        AnalysisResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AnalysisResult_Status>>(
                "status",
                |m: &AnalysisResult| { &m.status },
                |m: &mut AnalysisResult| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "summary",
                |m: &AnalysisResult| { &m.summary },
                |m: &mut AnalysisResult| { &mut m.summary },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                "details",
                |m: &AnalysisResult| { &m.details },
                |m: &mut AnalysisResult| { &mut m.details },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AnalysisResult>(
                "AnalysisResult",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AnalysisResult {
        static instance: ::protobuf::rt::LazyV2<AnalysisResult> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AnalysisResult::new)
    }
}

impl ::protobuf::Clear for AnalysisResult {
    fn clear(&mut self) {
        self.status = AnalysisResult_Status::COMPLETE;
        self.summary.clear();
        self.details.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AnalysisResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AnalysisResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AnalysisResult_Status {
    COMPLETE = 0,
    INCOMPLETE = 1,
    INVALID_REQUEST = 2,
}

impl ::protobuf::ProtobufEnum for AnalysisResult_Status {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AnalysisResult_Status> {
        match value {
            0 => ::std::option::Option::Some(AnalysisResult_Status::COMPLETE),
            1 => ::std::option::Option::Some(AnalysisResult_Status::INCOMPLETE),
            2 => ::std::option::Option::Some(AnalysisResult_Status::INVALID_REQUEST),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AnalysisResult_Status] = &[
            AnalysisResult_Status::COMPLETE,
            AnalysisResult_Status::INCOMPLETE,
            AnalysisResult_Status::INVALID_REQUEST,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<AnalysisResult_Status>("AnalysisResult.Status", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for AnalysisResult_Status {
}

impl ::std::default::Default for AnalysisResult_Status {
    fn default() -> Self {
        AnalysisResult_Status::COMPLETE
    }
}

impl ::protobuf::reflect::ProtobufValue for AnalysisResult_Status {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CompilationUnit {
    // message fields
    pub v_name: ::protobuf::SingularPtrField<super::storage::VName>,
    pub required_input: ::protobuf::RepeatedField<CompilationUnit_FileInput>,
    pub has_compile_errors: bool,
    pub argument: ::protobuf::RepeatedField<::std::string::String>,
    pub source_file: ::protobuf::RepeatedField<::std::string::String>,
    pub output_key: ::std::string::String,
    pub working_directory: ::std::string::String,
    pub entry_context: ::std::string::String,
    pub environment: ::protobuf::RepeatedField<CompilationUnit_Env>,
    pub details: ::protobuf::RepeatedField<::protobuf::well_known_types::Any>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CompilationUnit {
    fn default() -> &'a CompilationUnit {
        <CompilationUnit as ::protobuf::Message>::default_instance()
    }
}

impl CompilationUnit {
    pub fn new() -> CompilationUnit {
        ::std::default::Default::default()
    }

    // .kythe.proto.VName v_name = 1;


    pub fn get_v_name(&self) -> &super::storage::VName {
        self.v_name.as_ref().unwrap_or_else(|| <super::storage::VName as ::protobuf::Message>::default_instance())
    }
    pub fn clear_v_name(&mut self) {
        self.v_name.clear();
    }

    pub fn has_v_name(&self) -> bool {
        self.v_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_v_name(&mut self, v: super::storage::VName) {
        self.v_name = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_v_name(&mut self) -> &mut super::storage::VName {
        if self.v_name.is_none() {
            self.v_name.set_default();
        }
        self.v_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_v_name(&mut self) -> super::storage::VName {
        self.v_name.take().unwrap_or_else(|| super::storage::VName::new())
    }

    // repeated .kythe.proto.CompilationUnit.FileInput required_input = 3;


    pub fn get_required_input(&self) -> &[CompilationUnit_FileInput] {
        &self.required_input
    }
    pub fn clear_required_input(&mut self) {
        self.required_input.clear();
    }

    // Param is passed by value, moved
    pub fn set_required_input(&mut self, v: ::protobuf::RepeatedField<CompilationUnit_FileInput>) {
        self.required_input = v;
    }

    // Mutable pointer to the field.
    pub fn mut_required_input(&mut self) -> &mut ::protobuf::RepeatedField<CompilationUnit_FileInput> {
        &mut self.required_input
    }

    // Take field
    pub fn take_required_input(&mut self) -> ::protobuf::RepeatedField<CompilationUnit_FileInput> {
        ::std::mem::replace(&mut self.required_input, ::protobuf::RepeatedField::new())
    }

    // bool has_compile_errors = 4;


    pub fn get_has_compile_errors(&self) -> bool {
        self.has_compile_errors
    }
    pub fn clear_has_compile_errors(&mut self) {
        self.has_compile_errors = false;
    }

    // Param is passed by value, moved
    pub fn set_has_compile_errors(&mut self, v: bool) {
        self.has_compile_errors = v;
    }

    // repeated string argument = 5;


    pub fn get_argument(&self) -> &[::std::string::String] {
        &self.argument
    }
    pub fn clear_argument(&mut self) {
        self.argument.clear();
    }

    // Param is passed by value, moved
    pub fn set_argument(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.argument = v;
    }

    // Mutable pointer to the field.
    pub fn mut_argument(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.argument
    }

    // Take field
    pub fn take_argument(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.argument, ::protobuf::RepeatedField::new())
    }

    // repeated string source_file = 6;


    pub fn get_source_file(&self) -> &[::std::string::String] {
        &self.source_file
    }
    pub fn clear_source_file(&mut self) {
        self.source_file.clear();
    }

    // Param is passed by value, moved
    pub fn set_source_file(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.source_file = v;
    }

    // Mutable pointer to the field.
    pub fn mut_source_file(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.source_file
    }

    // Take field
    pub fn take_source_file(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.source_file, ::protobuf::RepeatedField::new())
    }

    // string output_key = 7;


    pub fn get_output_key(&self) -> &str {
        &self.output_key
    }
    pub fn clear_output_key(&mut self) {
        self.output_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_output_key(&mut self, v: ::std::string::String) {
        self.output_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_output_key(&mut self) -> &mut ::std::string::String {
        &mut self.output_key
    }

    // Take field
    pub fn take_output_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.output_key, ::std::string::String::new())
    }

    // string working_directory = 8;


    pub fn get_working_directory(&self) -> &str {
        &self.working_directory
    }
    pub fn clear_working_directory(&mut self) {
        self.working_directory.clear();
    }

    // Param is passed by value, moved
    pub fn set_working_directory(&mut self, v: ::std::string::String) {
        self.working_directory = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_working_directory(&mut self) -> &mut ::std::string::String {
        &mut self.working_directory
    }

    // Take field
    pub fn take_working_directory(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.working_directory, ::std::string::String::new())
    }

    // string entry_context = 9;


    pub fn get_entry_context(&self) -> &str {
        &self.entry_context
    }
    pub fn clear_entry_context(&mut self) {
        self.entry_context.clear();
    }

    // Param is passed by value, moved
    pub fn set_entry_context(&mut self, v: ::std::string::String) {
        self.entry_context = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entry_context(&mut self) -> &mut ::std::string::String {
        &mut self.entry_context
    }

    // Take field
    pub fn take_entry_context(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.entry_context, ::std::string::String::new())
    }

    // repeated .kythe.proto.CompilationUnit.Env environment = 10;


    pub fn get_environment(&self) -> &[CompilationUnit_Env] {
        &self.environment
    }
    pub fn clear_environment(&mut self) {
        self.environment.clear();
    }

    // Param is passed by value, moved
    pub fn set_environment(&mut self, v: ::protobuf::RepeatedField<CompilationUnit_Env>) {
        self.environment = v;
    }

    // Mutable pointer to the field.
    pub fn mut_environment(&mut self) -> &mut ::protobuf::RepeatedField<CompilationUnit_Env> {
        &mut self.environment
    }

    // Take field
    pub fn take_environment(&mut self) -> ::protobuf::RepeatedField<CompilationUnit_Env> {
        ::std::mem::replace(&mut self.environment, ::protobuf::RepeatedField::new())
    }

    // repeated .google.protobuf.Any details = 11;


    pub fn get_details(&self) -> &[::protobuf::well_known_types::Any] {
        &self.details
    }
    pub fn clear_details(&mut self) {
        self.details.clear();
    }

    // Param is passed by value, moved
    pub fn set_details(&mut self, v: ::protobuf::RepeatedField<::protobuf::well_known_types::Any>) {
        self.details = v;
    }

    // Mutable pointer to the field.
    pub fn mut_details(&mut self) -> &mut ::protobuf::RepeatedField<::protobuf::well_known_types::Any> {
        &mut self.details
    }

    // Take field
    pub fn take_details(&mut self) -> ::protobuf::RepeatedField<::protobuf::well_known_types::Any> {
        ::std::mem::replace(&mut self.details, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CompilationUnit {
    fn is_initialized(&self) -> bool {
        for v in &self.v_name {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.required_input {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.environment {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.details {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.v_name)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.required_input)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_compile_errors = tmp;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.argument)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.source_file)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.output_key)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.working_directory)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.entry_context)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.environment)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.details)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.v_name.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.required_input {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.has_compile_errors != false {
            my_size += 2;
        }
        for value in &self.argument {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        for value in &self.source_file {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        if !self.output_key.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.output_key);
        }
        if !self.working_directory.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.working_directory);
        }
        if !self.entry_context.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.entry_context);
        }
        for value in &self.environment {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.details {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.v_name.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.required_input {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.has_compile_errors != false {
            os.write_bool(4, self.has_compile_errors)?;
        }
        for v in &self.argument {
            os.write_string(5, &v)?;
        };
        for v in &self.source_file {
            os.write_string(6, &v)?;
        };
        if !self.output_key.is_empty() {
            os.write_string(7, &self.output_key)?;
        }
        if !self.working_directory.is_empty() {
            os.write_string(8, &self.working_directory)?;
        }
        if !self.entry_context.is_empty() {
            os.write_string(9, &self.entry_context)?;
        }
        for v in &self.environment {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.details {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CompilationUnit {
        CompilationUnit::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::storage::VName>>(
                "v_name",
                |m: &CompilationUnit| { &m.v_name },
                |m: &mut CompilationUnit| { &mut m.v_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CompilationUnit_FileInput>>(
                "required_input",
                |m: &CompilationUnit| { &m.required_input },
                |m: &mut CompilationUnit| { &mut m.required_input },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_compile_errors",
                |m: &CompilationUnit| { &m.has_compile_errors },
                |m: &mut CompilationUnit| { &mut m.has_compile_errors },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "argument",
                |m: &CompilationUnit| { &m.argument },
                |m: &mut CompilationUnit| { &mut m.argument },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "source_file",
                |m: &CompilationUnit| { &m.source_file },
                |m: &mut CompilationUnit| { &mut m.source_file },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "output_key",
                |m: &CompilationUnit| { &m.output_key },
                |m: &mut CompilationUnit| { &mut m.output_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "working_directory",
                |m: &CompilationUnit| { &m.working_directory },
                |m: &mut CompilationUnit| { &mut m.working_directory },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "entry_context",
                |m: &CompilationUnit| { &m.entry_context },
                |m: &mut CompilationUnit| { &mut m.entry_context },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CompilationUnit_Env>>(
                "environment",
                |m: &CompilationUnit| { &m.environment },
                |m: &mut CompilationUnit| { &mut m.environment },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                "details",
                |m: &CompilationUnit| { &m.details },
                |m: &mut CompilationUnit| { &mut m.details },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CompilationUnit>(
                "CompilationUnit",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CompilationUnit {
        static instance: ::protobuf::rt::LazyV2<CompilationUnit> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CompilationUnit::new)
    }
}

impl ::protobuf::Clear for CompilationUnit {
    fn clear(&mut self) {
        self.v_name.clear();
        self.required_input.clear();
        self.has_compile_errors = false;
        self.argument.clear();
        self.source_file.clear();
        self.output_key.clear();
        self.working_directory.clear();
        self.entry_context.clear();
        self.environment.clear();
        self.details.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CompilationUnit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CompilationUnit {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CompilationUnit_FileInput {
    // message fields
    pub v_name: ::protobuf::SingularPtrField<super::storage::VName>,
    pub info: ::protobuf::SingularPtrField<FileInfo>,
    pub details: ::protobuf::RepeatedField<::protobuf::well_known_types::Any>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CompilationUnit_FileInput {
    fn default() -> &'a CompilationUnit_FileInput {
        <CompilationUnit_FileInput as ::protobuf::Message>::default_instance()
    }
}

impl CompilationUnit_FileInput {
    pub fn new() -> CompilationUnit_FileInput {
        ::std::default::Default::default()
    }

    // .kythe.proto.VName v_name = 1;


    pub fn get_v_name(&self) -> &super::storage::VName {
        self.v_name.as_ref().unwrap_or_else(|| <super::storage::VName as ::protobuf::Message>::default_instance())
    }
    pub fn clear_v_name(&mut self) {
        self.v_name.clear();
    }

    pub fn has_v_name(&self) -> bool {
        self.v_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_v_name(&mut self, v: super::storage::VName) {
        self.v_name = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_v_name(&mut self) -> &mut super::storage::VName {
        if self.v_name.is_none() {
            self.v_name.set_default();
        }
        self.v_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_v_name(&mut self) -> super::storage::VName {
        self.v_name.take().unwrap_or_else(|| super::storage::VName::new())
    }

    // .kythe.proto.FileInfo info = 2;


    pub fn get_info(&self) -> &FileInfo {
        self.info.as_ref().unwrap_or_else(|| <FileInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: FileInfo) {
        self.info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut FileInfo {
        if self.info.is_none() {
            self.info.set_default();
        }
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> FileInfo {
        self.info.take().unwrap_or_else(|| FileInfo::new())
    }

    // repeated .google.protobuf.Any details = 4;


    pub fn get_details(&self) -> &[::protobuf::well_known_types::Any] {
        &self.details
    }
    pub fn clear_details(&mut self) {
        self.details.clear();
    }

    // Param is passed by value, moved
    pub fn set_details(&mut self, v: ::protobuf::RepeatedField<::protobuf::well_known_types::Any>) {
        self.details = v;
    }

    // Mutable pointer to the field.
    pub fn mut_details(&mut self) -> &mut ::protobuf::RepeatedField<::protobuf::well_known_types::Any> {
        &mut self.details
    }

    // Take field
    pub fn take_details(&mut self) -> ::protobuf::RepeatedField<::protobuf::well_known_types::Any> {
        ::std::mem::replace(&mut self.details, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CompilationUnit_FileInput {
    fn is_initialized(&self) -> bool {
        for v in &self.v_name {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.details {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.v_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.info)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.details)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.v_name.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.details {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.v_name.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.info.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.details {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CompilationUnit_FileInput {
        CompilationUnit_FileInput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::storage::VName>>(
                "v_name",
                |m: &CompilationUnit_FileInput| { &m.v_name },
                |m: &mut CompilationUnit_FileInput| { &mut m.v_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FileInfo>>(
                "info",
                |m: &CompilationUnit_FileInput| { &m.info },
                |m: &mut CompilationUnit_FileInput| { &mut m.info },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                "details",
                |m: &CompilationUnit_FileInput| { &m.details },
                |m: &mut CompilationUnit_FileInput| { &mut m.details },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CompilationUnit_FileInput>(
                "CompilationUnit.FileInput",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CompilationUnit_FileInput {
        static instance: ::protobuf::rt::LazyV2<CompilationUnit_FileInput> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CompilationUnit_FileInput::new)
    }
}

impl ::protobuf::Clear for CompilationUnit_FileInput {
    fn clear(&mut self) {
        self.v_name.clear();
        self.info.clear();
        self.details.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CompilationUnit_FileInput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CompilationUnit_FileInput {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CompilationUnit_Env {
    // message fields
    pub name: ::std::string::String,
    pub value: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CompilationUnit_Env {
    fn default() -> &'a CompilationUnit_Env {
        <CompilationUnit_Env as ::protobuf::Message>::default_instance()
    }
}

impl CompilationUnit_Env {
    pub fn new() -> CompilationUnit_Env {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string value = 2;


    pub fn get_value(&self) -> &str {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.value, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CompilationUnit_Env {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.value.is_empty() {
            os.write_string(2, &self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CompilationUnit_Env {
        CompilationUnit_Env::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &CompilationUnit_Env| { &m.name },
                |m: &mut CompilationUnit_Env| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "value",
                |m: &CompilationUnit_Env| { &m.value },
                |m: &mut CompilationUnit_Env| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CompilationUnit_Env>(
                "CompilationUnit.Env",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CompilationUnit_Env {
        static instance: ::protobuf::rt::LazyV2<CompilationUnit_Env> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CompilationUnit_Env::new)
    }
}

impl ::protobuf::Clear for CompilationUnit_Env {
    fn clear(&mut self) {
        self.name.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CompilationUnit_Env {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CompilationUnit_Env {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KzipInfo {
    // message fields
    pub corpora: ::std::collections::HashMap<::std::string::String, KzipInfo_CorpusInfo>,
    pub size: i64,
    pub absolute_paths: ::protobuf::RepeatedField<::std::string::String>,
    pub critical_kzip_errors: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KzipInfo {
    fn default() -> &'a KzipInfo {
        <KzipInfo as ::protobuf::Message>::default_instance()
    }
}

impl KzipInfo {
    pub fn new() -> KzipInfo {
        ::std::default::Default::default()
    }

    // repeated .kythe.proto.KzipInfo.CorporaEntry corpora = 1;


    pub fn get_corpora(&self) -> &::std::collections::HashMap<::std::string::String, KzipInfo_CorpusInfo> {
        &self.corpora
    }
    pub fn clear_corpora(&mut self) {
        self.corpora.clear();
    }

    // Param is passed by value, moved
    pub fn set_corpora(&mut self, v: ::std::collections::HashMap<::std::string::String, KzipInfo_CorpusInfo>) {
        self.corpora = v;
    }

    // Mutable pointer to the field.
    pub fn mut_corpora(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, KzipInfo_CorpusInfo> {
        &mut self.corpora
    }

    // Take field
    pub fn take_corpora(&mut self) -> ::std::collections::HashMap<::std::string::String, KzipInfo_CorpusInfo> {
        ::std::mem::replace(&mut self.corpora, ::std::collections::HashMap::new())
    }

    // int64 size = 4;


    pub fn get_size(&self) -> i64 {
        self.size
    }
    pub fn clear_size(&mut self) {
        self.size = 0;
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: i64) {
        self.size = v;
    }

    // repeated string absolute_paths = 6;


    pub fn get_absolute_paths(&self) -> &[::std::string::String] {
        &self.absolute_paths
    }
    pub fn clear_absolute_paths(&mut self) {
        self.absolute_paths.clear();
    }

    // Param is passed by value, moved
    pub fn set_absolute_paths(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.absolute_paths = v;
    }

    // Mutable pointer to the field.
    pub fn mut_absolute_paths(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.absolute_paths
    }

    // Take field
    pub fn take_absolute_paths(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.absolute_paths, ::protobuf::RepeatedField::new())
    }

    // repeated string critical_kzip_errors = 5;


    pub fn get_critical_kzip_errors(&self) -> &[::std::string::String] {
        &self.critical_kzip_errors
    }
    pub fn clear_critical_kzip_errors(&mut self) {
        self.critical_kzip_errors.clear();
    }

    // Param is passed by value, moved
    pub fn set_critical_kzip_errors(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.critical_kzip_errors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_critical_kzip_errors(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.critical_kzip_errors
    }

    // Take field
    pub fn take_critical_kzip_errors(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.critical_kzip_errors, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for KzipInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<KzipInfo_CorpusInfo>>(wire_type, is, &mut self.corpora)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.size = tmp;
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.absolute_paths)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.critical_kzip_errors)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<KzipInfo_CorpusInfo>>(1, &self.corpora);
        if self.size != 0 {
            my_size += ::protobuf::rt::value_size(4, self.size, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.absolute_paths {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        for value in &self.critical_kzip_errors {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<KzipInfo_CorpusInfo>>(1, &self.corpora, os)?;
        if self.size != 0 {
            os.write_int64(4, self.size)?;
        }
        for v in &self.absolute_paths {
            os.write_string(6, &v)?;
        };
        for v in &self.critical_kzip_errors {
            os.write_string(5, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KzipInfo {
        KzipInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<KzipInfo_CorpusInfo>>(
                "corpora",
                |m: &KzipInfo| { &m.corpora },
                |m: &mut KzipInfo| { &mut m.corpora },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "size",
                |m: &KzipInfo| { &m.size },
                |m: &mut KzipInfo| { &mut m.size },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "absolute_paths",
                |m: &KzipInfo| { &m.absolute_paths },
                |m: &mut KzipInfo| { &mut m.absolute_paths },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "critical_kzip_errors",
                |m: &KzipInfo| { &m.critical_kzip_errors },
                |m: &mut KzipInfo| { &mut m.critical_kzip_errors },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<KzipInfo>(
                "KzipInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static KzipInfo {
        static instance: ::protobuf::rt::LazyV2<KzipInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(KzipInfo::new)
    }
}

impl ::protobuf::Clear for KzipInfo {
    fn clear(&mut self) {
        self.corpora.clear();
        self.size = 0;
        self.absolute_paths.clear();
        self.critical_kzip_errors.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KzipInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KzipInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KzipInfo_CorpusInfo {
    // message fields
    pub language_required_inputs: ::std::collections::HashMap<::std::string::String, KzipInfo_CorpusInfo_Inputs>,
    pub language_sources: ::std::collections::HashMap<::std::string::String, KzipInfo_CorpusInfo_Inputs>,
    pub language_cu_info: ::std::collections::HashMap<::std::string::String, KzipInfo_CorpusInfo_CUInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KzipInfo_CorpusInfo {
    fn default() -> &'a KzipInfo_CorpusInfo {
        <KzipInfo_CorpusInfo as ::protobuf::Message>::default_instance()
    }
}

impl KzipInfo_CorpusInfo {
    pub fn new() -> KzipInfo_CorpusInfo {
        ::std::default::Default::default()
    }

    // repeated .kythe.proto.KzipInfo.CorpusInfo.LanguageRequiredInputsEntry language_required_inputs = 4;


    pub fn get_language_required_inputs(&self) -> &::std::collections::HashMap<::std::string::String, KzipInfo_CorpusInfo_Inputs> {
        &self.language_required_inputs
    }
    pub fn clear_language_required_inputs(&mut self) {
        self.language_required_inputs.clear();
    }

    // Param is passed by value, moved
    pub fn set_language_required_inputs(&mut self, v: ::std::collections::HashMap<::std::string::String, KzipInfo_CorpusInfo_Inputs>) {
        self.language_required_inputs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_language_required_inputs(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, KzipInfo_CorpusInfo_Inputs> {
        &mut self.language_required_inputs
    }

    // Take field
    pub fn take_language_required_inputs(&mut self) -> ::std::collections::HashMap<::std::string::String, KzipInfo_CorpusInfo_Inputs> {
        ::std::mem::replace(&mut self.language_required_inputs, ::std::collections::HashMap::new())
    }

    // repeated .kythe.proto.KzipInfo.CorpusInfo.LanguageSourcesEntry language_sources = 5;


    pub fn get_language_sources(&self) -> &::std::collections::HashMap<::std::string::String, KzipInfo_CorpusInfo_Inputs> {
        &self.language_sources
    }
    pub fn clear_language_sources(&mut self) {
        self.language_sources.clear();
    }

    // Param is passed by value, moved
    pub fn set_language_sources(&mut self, v: ::std::collections::HashMap<::std::string::String, KzipInfo_CorpusInfo_Inputs>) {
        self.language_sources = v;
    }

    // Mutable pointer to the field.
    pub fn mut_language_sources(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, KzipInfo_CorpusInfo_Inputs> {
        &mut self.language_sources
    }

    // Take field
    pub fn take_language_sources(&mut self) -> ::std::collections::HashMap<::std::string::String, KzipInfo_CorpusInfo_Inputs> {
        ::std::mem::replace(&mut self.language_sources, ::std::collections::HashMap::new())
    }

    // repeated .kythe.proto.KzipInfo.CorpusInfo.LanguageCuInfoEntry language_cu_info = 6;


    pub fn get_language_cu_info(&self) -> &::std::collections::HashMap<::std::string::String, KzipInfo_CorpusInfo_CUInfo> {
        &self.language_cu_info
    }
    pub fn clear_language_cu_info(&mut self) {
        self.language_cu_info.clear();
    }

    // Param is passed by value, moved
    pub fn set_language_cu_info(&mut self, v: ::std::collections::HashMap<::std::string::String, KzipInfo_CorpusInfo_CUInfo>) {
        self.language_cu_info = v;
    }

    // Mutable pointer to the field.
    pub fn mut_language_cu_info(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, KzipInfo_CorpusInfo_CUInfo> {
        &mut self.language_cu_info
    }

    // Take field
    pub fn take_language_cu_info(&mut self) -> ::std::collections::HashMap<::std::string::String, KzipInfo_CorpusInfo_CUInfo> {
        ::std::mem::replace(&mut self.language_cu_info, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for KzipInfo_CorpusInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                4 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<KzipInfo_CorpusInfo_Inputs>>(wire_type, is, &mut self.language_required_inputs)?;
                },
                5 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<KzipInfo_CorpusInfo_Inputs>>(wire_type, is, &mut self.language_sources)?;
                },
                6 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<KzipInfo_CorpusInfo_CUInfo>>(wire_type, is, &mut self.language_cu_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<KzipInfo_CorpusInfo_Inputs>>(4, &self.language_required_inputs);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<KzipInfo_CorpusInfo_Inputs>>(5, &self.language_sources);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<KzipInfo_CorpusInfo_CUInfo>>(6, &self.language_cu_info);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<KzipInfo_CorpusInfo_Inputs>>(4, &self.language_required_inputs, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<KzipInfo_CorpusInfo_Inputs>>(5, &self.language_sources, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<KzipInfo_CorpusInfo_CUInfo>>(6, &self.language_cu_info, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KzipInfo_CorpusInfo {
        KzipInfo_CorpusInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<KzipInfo_CorpusInfo_Inputs>>(
                "language_required_inputs",
                |m: &KzipInfo_CorpusInfo| { &m.language_required_inputs },
                |m: &mut KzipInfo_CorpusInfo| { &mut m.language_required_inputs },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<KzipInfo_CorpusInfo_Inputs>>(
                "language_sources",
                |m: &KzipInfo_CorpusInfo| { &m.language_sources },
                |m: &mut KzipInfo_CorpusInfo| { &mut m.language_sources },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<KzipInfo_CorpusInfo_CUInfo>>(
                "language_cu_info",
                |m: &KzipInfo_CorpusInfo| { &m.language_cu_info },
                |m: &mut KzipInfo_CorpusInfo| { &mut m.language_cu_info },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<KzipInfo_CorpusInfo>(
                "KzipInfo.CorpusInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static KzipInfo_CorpusInfo {
        static instance: ::protobuf::rt::LazyV2<KzipInfo_CorpusInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(KzipInfo_CorpusInfo::new)
    }
}

impl ::protobuf::Clear for KzipInfo_CorpusInfo {
    fn clear(&mut self) {
        self.language_required_inputs.clear();
        self.language_sources.clear();
        self.language_cu_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KzipInfo_CorpusInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KzipInfo_CorpusInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KzipInfo_CorpusInfo_Inputs {
    // message fields
    pub count: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KzipInfo_CorpusInfo_Inputs {
    fn default() -> &'a KzipInfo_CorpusInfo_Inputs {
        <KzipInfo_CorpusInfo_Inputs as ::protobuf::Message>::default_instance()
    }
}

impl KzipInfo_CorpusInfo_Inputs {
    pub fn new() -> KzipInfo_CorpusInfo_Inputs {
        ::std::default::Default::default()
    }

    // int32 count = 1;


    pub fn get_count(&self) -> i32 {
        self.count
    }
    pub fn clear_count(&mut self) {
        self.count = 0;
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: i32) {
        self.count = v;
    }
}

impl ::protobuf::Message for KzipInfo_CorpusInfo_Inputs {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.count = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.count != 0 {
            my_size += ::protobuf::rt::value_size(1, self.count, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.count != 0 {
            os.write_int32(1, self.count)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KzipInfo_CorpusInfo_Inputs {
        KzipInfo_CorpusInfo_Inputs::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "count",
                |m: &KzipInfo_CorpusInfo_Inputs| { &m.count },
                |m: &mut KzipInfo_CorpusInfo_Inputs| { &mut m.count },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<KzipInfo_CorpusInfo_Inputs>(
                "KzipInfo.CorpusInfo.Inputs",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static KzipInfo_CorpusInfo_Inputs {
        static instance: ::protobuf::rt::LazyV2<KzipInfo_CorpusInfo_Inputs> = ::protobuf::rt::LazyV2::INIT;
        instance.get(KzipInfo_CorpusInfo_Inputs::new)
    }
}

impl ::protobuf::Clear for KzipInfo_CorpusInfo_Inputs {
    fn clear(&mut self) {
        self.count = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KzipInfo_CorpusInfo_Inputs {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KzipInfo_CorpusInfo_Inputs {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KzipInfo_CorpusInfo_CUInfo {
    // message fields
    pub count: i32,
    pub java_version_count: ::std::collections::HashMap<i32, i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KzipInfo_CorpusInfo_CUInfo {
    fn default() -> &'a KzipInfo_CorpusInfo_CUInfo {
        <KzipInfo_CorpusInfo_CUInfo as ::protobuf::Message>::default_instance()
    }
}

impl KzipInfo_CorpusInfo_CUInfo {
    pub fn new() -> KzipInfo_CorpusInfo_CUInfo {
        ::std::default::Default::default()
    }

    // int32 count = 1;


    pub fn get_count(&self) -> i32 {
        self.count
    }
    pub fn clear_count(&mut self) {
        self.count = 0;
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: i32) {
        self.count = v;
    }

    // repeated .kythe.proto.KzipInfo.CorpusInfo.CUInfo.JavaVersionCountEntry java_version_count = 2;


    pub fn get_java_version_count(&self) -> &::std::collections::HashMap<i32, i32> {
        &self.java_version_count
    }
    pub fn clear_java_version_count(&mut self) {
        self.java_version_count.clear();
    }

    // Param is passed by value, moved
    pub fn set_java_version_count(&mut self, v: ::std::collections::HashMap<i32, i32>) {
        self.java_version_count = v;
    }

    // Mutable pointer to the field.
    pub fn mut_java_version_count(&mut self) -> &mut ::std::collections::HashMap<i32, i32> {
        &mut self.java_version_count
    }

    // Take field
    pub fn take_java_version_count(&mut self) -> ::std::collections::HashMap<i32, i32> {
        ::std::mem::replace(&mut self.java_version_count, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for KzipInfo_CorpusInfo_CUInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.count = tmp;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeInt32, ::protobuf::types::ProtobufTypeInt32>(wire_type, is, &mut self.java_version_count)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.count != 0 {
            my_size += ::protobuf::rt::value_size(1, self.count, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeInt32, ::protobuf::types::ProtobufTypeInt32>(2, &self.java_version_count);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.count != 0 {
            os.write_int32(1, self.count)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeInt32, ::protobuf::types::ProtobufTypeInt32>(2, &self.java_version_count, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KzipInfo_CorpusInfo_CUInfo {
        KzipInfo_CorpusInfo_CUInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "count",
                |m: &KzipInfo_CorpusInfo_CUInfo| { &m.count },
                |m: &mut KzipInfo_CorpusInfo_CUInfo| { &mut m.count },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeInt32, ::protobuf::types::ProtobufTypeInt32>(
                "java_version_count",
                |m: &KzipInfo_CorpusInfo_CUInfo| { &m.java_version_count },
                |m: &mut KzipInfo_CorpusInfo_CUInfo| { &mut m.java_version_count },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<KzipInfo_CorpusInfo_CUInfo>(
                "KzipInfo.CorpusInfo.CUInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static KzipInfo_CorpusInfo_CUInfo {
        static instance: ::protobuf::rt::LazyV2<KzipInfo_CorpusInfo_CUInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(KzipInfo_CorpusInfo_CUInfo::new)
    }
}

impl ::protobuf::Clear for KzipInfo_CorpusInfo_CUInfo {
    fn clear(&mut self) {
        self.count = 0;
        self.java_version_count.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KzipInfo_CorpusInfo_CUInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KzipInfo_CorpusInfo_CUInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BuildMetadata {
    // message fields
    pub commit_timestamp: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BuildMetadata {
    fn default() -> &'a BuildMetadata {
        <BuildMetadata as ::protobuf::Message>::default_instance()
    }
}

impl BuildMetadata {
    pub fn new() -> BuildMetadata {
        ::std::default::Default::default()
    }

    // .google.protobuf.Timestamp commit_timestamp = 1;


    pub fn get_commit_timestamp(&self) -> &::protobuf::well_known_types::Timestamp {
        self.commit_timestamp.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_commit_timestamp(&mut self) {
        self.commit_timestamp.clear();
    }

    pub fn has_commit_timestamp(&self) -> bool {
        self.commit_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commit_timestamp(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.commit_timestamp = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commit_timestamp(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.commit_timestamp.is_none() {
            self.commit_timestamp.set_default();
        }
        self.commit_timestamp.as_mut().unwrap()
    }

    // Take field
    pub fn take_commit_timestamp(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.commit_timestamp.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for BuildMetadata {
    fn is_initialized(&self) -> bool {
        for v in &self.commit_timestamp {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commit_timestamp)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.commit_timestamp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.commit_timestamp.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BuildMetadata {
        BuildMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "commit_timestamp",
                |m: &BuildMetadata| { &m.commit_timestamp },
                |m: &mut BuildMetadata| { &mut m.commit_timestamp },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BuildMetadata>(
                "BuildMetadata",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BuildMetadata {
        static instance: ::protobuf::rt::LazyV2<BuildMetadata> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BuildMetadata::new)
    }
}

impl ::protobuf::Clear for BuildMetadata {
    fn clear(&mut self) {
        self.commit_timestamp.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BuildMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BuildMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FilesRequest {
    // message fields
    pub files: ::protobuf::RepeatedField<FileInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FilesRequest {
    fn default() -> &'a FilesRequest {
        <FilesRequest as ::protobuf::Message>::default_instance()
    }
}

impl FilesRequest {
    pub fn new() -> FilesRequest {
        ::std::default::Default::default()
    }

    // repeated .kythe.proto.FileInfo files = 1;


    pub fn get_files(&self) -> &[FileInfo] {
        &self.files
    }
    pub fn clear_files(&mut self) {
        self.files.clear();
    }

    // Param is passed by value, moved
    pub fn set_files(&mut self, v: ::protobuf::RepeatedField<FileInfo>) {
        self.files = v;
    }

    // Mutable pointer to the field.
    pub fn mut_files(&mut self) -> &mut ::protobuf::RepeatedField<FileInfo> {
        &mut self.files
    }

    // Take field
    pub fn take_files(&mut self) -> ::protobuf::RepeatedField<FileInfo> {
        ::std::mem::replace(&mut self.files, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for FilesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.files {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.files)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.files {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.files {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FilesRequest {
        FilesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FileInfo>>(
                "files",
                |m: &FilesRequest| { &m.files },
                |m: &mut FilesRequest| { &mut m.files },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FilesRequest>(
                "FilesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FilesRequest {
        static instance: ::protobuf::rt::LazyV2<FilesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FilesRequest::new)
    }
}

impl ::protobuf::Clear for FilesRequest {
    fn clear(&mut self) {
        self.files.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FilesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FilesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FileInfo {
    // message fields
    pub path: ::std::string::String,
    pub digest: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FileInfo {
    fn default() -> &'a FileInfo {
        <FileInfo as ::protobuf::Message>::default_instance()
    }
}

impl FileInfo {
    pub fn new() -> FileInfo {
        ::std::default::Default::default()
    }

    // string path = 1;


    pub fn get_path(&self) -> &str {
        &self.path
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        &mut self.path
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.path, ::std::string::String::new())
    }

    // string digest = 2;


    pub fn get_digest(&self) -> &str {
        &self.digest
    }
    pub fn clear_digest(&mut self) {
        self.digest.clear();
    }

    // Param is passed by value, moved
    pub fn set_digest(&mut self, v: ::std::string::String) {
        self.digest = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_digest(&mut self) -> &mut ::std::string::String {
        &mut self.digest
    }

    // Take field
    pub fn take_digest(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.digest, ::std::string::String::new())
    }
}

impl ::protobuf::Message for FileInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.path)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.digest)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.path);
        }
        if !self.digest.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.digest);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.path.is_empty() {
            os.write_string(1, &self.path)?;
        }
        if !self.digest.is_empty() {
            os.write_string(2, &self.digest)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FileInfo {
        FileInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "path",
                |m: &FileInfo| { &m.path },
                |m: &mut FileInfo| { &mut m.path },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "digest",
                |m: &FileInfo| { &m.digest },
                |m: &mut FileInfo| { &mut m.digest },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FileInfo>(
                "FileInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FileInfo {
        static instance: ::protobuf::rt::LazyV2<FileInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FileInfo::new)
    }
}

impl ::protobuf::Clear for FileInfo {
    fn clear(&mut self) {
        self.path.clear();
        self.digest.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FileInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FileData {
    // message fields
    pub content: ::std::vec::Vec<u8>,
    pub info: ::protobuf::SingularPtrField<FileInfo>,
    pub missing: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FileData {
    fn default() -> &'a FileData {
        <FileData as ::protobuf::Message>::default_instance()
    }
}

impl FileData {
    pub fn new() -> FileData {
        ::std::default::Default::default()
    }

    // bytes content = 1;


    pub fn get_content(&self) -> &[u8] {
        &self.content
    }
    pub fn clear_content(&mut self) {
        self.content.clear();
    }

    // Param is passed by value, moved
    pub fn set_content(&mut self, v: ::std::vec::Vec<u8>) {
        self.content = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_content(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.content
    }

    // Take field
    pub fn take_content(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.content, ::std::vec::Vec::new())
    }

    // .kythe.proto.FileInfo info = 2;


    pub fn get_info(&self) -> &FileInfo {
        self.info.as_ref().unwrap_or_else(|| <FileInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: FileInfo) {
        self.info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut FileInfo {
        if self.info.is_none() {
            self.info.set_default();
        }
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> FileInfo {
        self.info.take().unwrap_or_else(|| FileInfo::new())
    }

    // bool missing = 3;


    pub fn get_missing(&self) -> bool {
        self.missing
    }
    pub fn clear_missing(&mut self) {
        self.missing = false;
    }

    // Param is passed by value, moved
    pub fn set_missing(&mut self, v: bool) {
        self.missing = v;
    }
}

impl ::protobuf::Message for FileData {
    fn is_initialized(&self) -> bool {
        for v in &self.info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.content)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.info)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.missing = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.content.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.content);
        }
        if let Some(ref v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.missing != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.content.is_empty() {
            os.write_bytes(1, &self.content)?;
        }
        if let Some(ref v) = self.info.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.missing != false {
            os.write_bool(3, self.missing)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FileData {
        FileData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "content",
                |m: &FileData| { &m.content },
                |m: &mut FileData| { &mut m.content },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FileInfo>>(
                "info",
                |m: &FileData| { &m.info },
                |m: &mut FileData| { &mut m.info },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "missing",
                |m: &FileData| { &m.missing },
                |m: &mut FileData| { &mut m.missing },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FileData>(
                "FileData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FileData {
        static instance: ::protobuf::rt::LazyV2<FileData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FileData::new)
    }
}

impl ::protobuf::Clear for FileData {
    fn clear(&mut self) {
        self.content.clear();
        self.info.clear();
        self.missing = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FileData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CompilationBundle {
    // message fields
    pub unit: ::protobuf::SingularPtrField<CompilationUnit>,
    pub files: ::protobuf::RepeatedField<FileData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CompilationBundle {
    fn default() -> &'a CompilationBundle {
        <CompilationBundle as ::protobuf::Message>::default_instance()
    }
}

impl CompilationBundle {
    pub fn new() -> CompilationBundle {
        ::std::default::Default::default()
    }

    // .kythe.proto.CompilationUnit unit = 1;


    pub fn get_unit(&self) -> &CompilationUnit {
        self.unit.as_ref().unwrap_or_else(|| <CompilationUnit as ::protobuf::Message>::default_instance())
    }
    pub fn clear_unit(&mut self) {
        self.unit.clear();
    }

    pub fn has_unit(&self) -> bool {
        self.unit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit(&mut self, v: CompilationUnit) {
        self.unit = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unit(&mut self) -> &mut CompilationUnit {
        if self.unit.is_none() {
            self.unit.set_default();
        }
        self.unit.as_mut().unwrap()
    }

    // Take field
    pub fn take_unit(&mut self) -> CompilationUnit {
        self.unit.take().unwrap_or_else(|| CompilationUnit::new())
    }

    // repeated .kythe.proto.FileData files = 2;


    pub fn get_files(&self) -> &[FileData] {
        &self.files
    }
    pub fn clear_files(&mut self) {
        self.files.clear();
    }

    // Param is passed by value, moved
    pub fn set_files(&mut self, v: ::protobuf::RepeatedField<FileData>) {
        self.files = v;
    }

    // Mutable pointer to the field.
    pub fn mut_files(&mut self) -> &mut ::protobuf::RepeatedField<FileData> {
        &mut self.files
    }

    // Take field
    pub fn take_files(&mut self) -> ::protobuf::RepeatedField<FileData> {
        ::std::mem::replace(&mut self.files, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CompilationBundle {
    fn is_initialized(&self) -> bool {
        for v in &self.unit {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.files {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.unit)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.files)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.unit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.files {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.unit.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.files {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CompilationBundle {
        CompilationBundle::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CompilationUnit>>(
                "unit",
                |m: &CompilationBundle| { &m.unit },
                |m: &mut CompilationBundle| { &mut m.unit },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FileData>>(
                "files",
                |m: &CompilationBundle| { &m.files },
                |m: &mut CompilationBundle| { &mut m.files },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CompilationBundle>(
                "CompilationBundle",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CompilationBundle {
        static instance: ::protobuf::rt::LazyV2<CompilationBundle> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CompilationBundle::new)
    }
}

impl ::protobuf::Clear for CompilationBundle {
    fn clear(&mut self) {
        self.unit.clear();
        self.files.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CompilationBundle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CompilationBundle {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IndexedCompilation {
    // message fields
    pub unit: ::protobuf::SingularPtrField<CompilationUnit>,
    pub index: ::protobuf::SingularPtrField<IndexedCompilation_Index>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IndexedCompilation {
    fn default() -> &'a IndexedCompilation {
        <IndexedCompilation as ::protobuf::Message>::default_instance()
    }
}

impl IndexedCompilation {
    pub fn new() -> IndexedCompilation {
        ::std::default::Default::default()
    }

    // .kythe.proto.CompilationUnit unit = 1;


    pub fn get_unit(&self) -> &CompilationUnit {
        self.unit.as_ref().unwrap_or_else(|| <CompilationUnit as ::protobuf::Message>::default_instance())
    }
    pub fn clear_unit(&mut self) {
        self.unit.clear();
    }

    pub fn has_unit(&self) -> bool {
        self.unit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit(&mut self, v: CompilationUnit) {
        self.unit = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unit(&mut self) -> &mut CompilationUnit {
        if self.unit.is_none() {
            self.unit.set_default();
        }
        self.unit.as_mut().unwrap()
    }

    // Take field
    pub fn take_unit(&mut self) -> CompilationUnit {
        self.unit.take().unwrap_or_else(|| CompilationUnit::new())
    }

    // .kythe.proto.IndexedCompilation.Index index = 2;


    pub fn get_index(&self) -> &IndexedCompilation_Index {
        self.index.as_ref().unwrap_or_else(|| <IndexedCompilation_Index as ::protobuf::Message>::default_instance())
    }
    pub fn clear_index(&mut self) {
        self.index.clear();
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: IndexedCompilation_Index) {
        self.index = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_index(&mut self) -> &mut IndexedCompilation_Index {
        if self.index.is_none() {
            self.index.set_default();
        }
        self.index.as_mut().unwrap()
    }

    // Take field
    pub fn take_index(&mut self) -> IndexedCompilation_Index {
        self.index.take().unwrap_or_else(|| IndexedCompilation_Index::new())
    }
}

impl ::protobuf::Message for IndexedCompilation {
    fn is_initialized(&self) -> bool {
        for v in &self.unit {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.index {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.unit)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.index)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.unit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.index.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.unit.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.index.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IndexedCompilation {
        IndexedCompilation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CompilationUnit>>(
                "unit",
                |m: &IndexedCompilation| { &m.unit },
                |m: &mut IndexedCompilation| { &mut m.unit },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IndexedCompilation_Index>>(
                "index",
                |m: &IndexedCompilation| { &m.index },
                |m: &mut IndexedCompilation| { &mut m.index },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IndexedCompilation>(
                "IndexedCompilation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static IndexedCompilation {
        static instance: ::protobuf::rt::LazyV2<IndexedCompilation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IndexedCompilation::new)
    }
}

impl ::protobuf::Clear for IndexedCompilation {
    fn clear(&mut self) {
        self.unit.clear();
        self.index.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IndexedCompilation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IndexedCompilation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IndexedCompilation_Index {
    // message fields
    pub revisions: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IndexedCompilation_Index {
    fn default() -> &'a IndexedCompilation_Index {
        <IndexedCompilation_Index as ::protobuf::Message>::default_instance()
    }
}

impl IndexedCompilation_Index {
    pub fn new() -> IndexedCompilation_Index {
        ::std::default::Default::default()
    }

    // repeated string revisions = 1;


    pub fn get_revisions(&self) -> &[::std::string::String] {
        &self.revisions
    }
    pub fn clear_revisions(&mut self) {
        self.revisions.clear();
    }

    // Param is passed by value, moved
    pub fn set_revisions(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.revisions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_revisions(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.revisions
    }

    // Take field
    pub fn take_revisions(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.revisions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for IndexedCompilation_Index {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.revisions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.revisions {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.revisions {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IndexedCompilation_Index {
        IndexedCompilation_Index::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "revisions",
                |m: &IndexedCompilation_Index| { &m.revisions },
                |m: &mut IndexedCompilation_Index| { &mut m.revisions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IndexedCompilation_Index>(
                "IndexedCompilation.Index",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static IndexedCompilation_Index {
        static instance: ::protobuf::rt::LazyV2<IndexedCompilation_Index> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IndexedCompilation_Index::new)
    }
}

impl ::protobuf::Clear for IndexedCompilation_Index {
    fn clear(&mut self) {
        self.revisions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IndexedCompilation_Index {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IndexedCompilation_Index {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1akythe/proto/analysis.proto\x12\x0bkythe.proto\x1a\x19google/protob\
    uf/any.proto\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x19kythe/proto/s\
    torage.proto\"\xe3\x01\n\x0fAnalysisRequest\x12>\n\x0bcompilation\x18\
    \x01\x20\x01(\x0b2\x1c.kythe.proto.CompilationUnitR\x0bcompilation\x12*\
    \n\x11file_data_service\x18\x02\x20\x01(\tR\x0ffileDataService\x12\x1a\n\
    \x08revision\x18\x03\x20\x01(\tR\x08revision\x12\x19\n\x08build_id\x18\
    \x04\x20\x01(\tR\x07buildId\x12-\n\x12compilation_digest\x18\x05\x20\x01\
    (\tR\x11compilationDigest\"f\n\x0eAnalysisOutput\x12\x14\n\x05value\x18\
    \x01\x20\x01(\x0cR\x05value\x12>\n\x0cfinal_result\x18\n\x20\x01(\x0b2\
    \x1b.kythe.proto.AnalysisResultR\x0bfinalResult\"\xd3\x01\n\x0eAnalysisR\
    esult\x12:\n\x06status\x18\x01\x20\x01(\x0e2\".kythe.proto.AnalysisResul\
    t.StatusR\x06status\x12\x18\n\x07summary\x18\x02\x20\x01(\tR\x07summary\
    \x12.\n\x07details\x18\x03\x20\x03(\x0b2\x14.google.protobuf.AnyR\x07det\
    ails\";\n\x06Status\x12\x0c\n\x08COMPLETE\x10\0\x12\x0e\n\nINCOMPLETE\
    \x10\x01\x12\x13\n\x0fINVALID_REQUEST\x10\x02\"\xac\x05\n\x0fCompilation\
    Unit\x12)\n\x06v_name\x18\x01\x20\x01(\x0b2\x12.kythe.proto.VNameR\x05vN\
    ame\x12M\n\x0erequired_input\x18\x03\x20\x03(\x0b2&.kythe.proto.Compilat\
    ionUnit.FileInputR\rrequiredInput\x12,\n\x12has_compile_errors\x18\x04\
    \x20\x01(\x08R\x10hasCompileErrors\x12\x1a\n\x08argument\x18\x05\x20\x03\
    (\tR\x08argument\x12\x1f\n\x0bsource_file\x18\x06\x20\x03(\tR\nsourceFil\
    e\x12\x1d\n\noutput_key\x18\x07\x20\x01(\tR\toutputKey\x12+\n\x11working\
    _directory\x18\x08\x20\x01(\tR\x10workingDirectory\x12#\n\rentry_context\
    \x18\t\x20\x01(\tR\x0centryContext\x12B\n\x0benvironment\x18\n\x20\x03(\
    \x0b2\x20.kythe.proto.CompilationUnit.EnvR\x0benvironment\x12.\n\x07deta\
    ils\x18\x0b\x20\x03(\x0b2\x14.google.protobuf.AnyR\x07details\x1a\x97\
    \x01\n\tFileInput\x12)\n\x06v_name\x18\x01\x20\x01(\x0b2\x12.kythe.proto\
    .VNameR\x05vName\x12)\n\x04info\x18\x02\x20\x01(\x0b2\x15.kythe.proto.Fi\
    leInfoR\x04info\x12.\n\x07details\x18\x04\x20\x03(\x0b2\x14.google.proto\
    buf.AnyR\x07detailsJ\x04\x08\x03\x10\x04\x1a/\n\x03Env\x12\x12\n\x04name\
    \x18\x01\x20\x01(\tR\x04name\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05v\
    alueJ\x04\x08\x02\x10\x03\"\xba\t\n\x08KzipInfo\x12<\n\x07corpora\x18\
    \x01\x20\x03(\x0b2\".kythe.proto.KzipInfo.CorporaEntryR\x07corpora\x12\
    \x12\n\x04size\x18\x04\x20\x01(\x03R\x04size\x12%\n\x0eabsolute_paths\
    \x18\x06\x20\x03(\tR\rabsolutePaths\x120\n\x14critical_kzip_errors\x18\
    \x05\x20\x03(\tR\x12criticalKzipErrors\x1a\x98\x07\n\nCorpusInfo\x12v\n\
    \x18language_required_inputs\x18\x04\x20\x03(\x0b2<.kythe.proto.KzipInfo\
    .CorpusInfo.LanguageRequiredInputsEntryR\x16languageRequiredInputs\x12`\
    \n\x10language_sources\x18\x05\x20\x03(\x0b25.kythe.proto.KzipInfo.Corpu\
    sInfo.LanguageSourcesEntryR\x0flanguageSources\x12^\n\x10language_cu_inf\
    o\x18\x06\x20\x03(\x0b24.kythe.proto.KzipInfo.CorpusInfo.LanguageCuInfoE\
    ntryR\x0elanguageCuInfo\x1a\x1e\n\x06Inputs\x12\x14\n\x05count\x18\x01\
    \x20\x01(\x05R\x05count\x1a\xd0\x01\n\x06CUInfo\x12\x14\n\x05count\x18\
    \x01\x20\x01(\x05R\x05count\x12k\n\x12java_version_count\x18\x02\x20\x03\
    (\x0b2=.kythe.proto.KzipInfo.CorpusInfo.CUInfo.JavaVersionCountEntryR\
    \x10javaVersionCount\x1aC\n\x15JavaVersionCountEntry\x12\x10\n\x03key\
    \x18\x01\x20\x01(\x05R\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\x05R\
    \x05value:\x028\x01\x1ar\n\x1bLanguageRequiredInputsEntry\x12\x10\n\x03k\
    ey\x18\x01\x20\x01(\tR\x03key\x12=\n\x05value\x18\x02\x20\x01(\x0b2'.kyt\
    he.proto.KzipInfo.CorpusInfo.InputsR\x05value:\x028\x01\x1ak\n\x14Langua\
    geSourcesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12=\n\x05val\
    ue\x18\x02\x20\x01(\x0b2'.kythe.proto.KzipInfo.CorpusInfo.InputsR\x05val\
    ue:\x028\x01\x1aj\n\x13LanguageCuInfoEntry\x12\x10\n\x03key\x18\x01\x20\
    \x01(\tR\x03key\x12=\n\x05value\x18\x02\x20\x01(\x0b2'.kythe.proto.KzipI\
    nfo.CorpusInfo.CUInfoR\x05value:\x028\x01J\x04\x08\x01\x10\x02J\x04\x08\
    \x02\x10\x03J\x04\x08\x03\x10\x04\x1a\\\n\x0cCorporaEntry\x12\x10\n\x03k\
    ey\x18\x01\x20\x01(\tR\x03key\x126\n\x05value\x18\x02\x20\x01(\x0b2\x20.\
    kythe.proto.KzipInfo.CorpusInfoR\x05value:\x028\x01J\x04\x08\x02\x10\x03\
    J\x04\x08\x03\x10\x04\"V\n\rBuildMetadata\x12E\n\x10commit_timestamp\x18\
    \x01\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x0fcommitTimestamp\";\
    \n\x0cFilesRequest\x12+\n\x05files\x18\x01\x20\x03(\x0b2\x15.kythe.proto\
    .FileInfoR\x05files\"6\n\x08FileInfo\x12\x12\n\x04path\x18\x01\x20\x01(\
    \tR\x04path\x12\x16\n\x06digest\x18\x02\x20\x01(\tR\x06digest\"i\n\x08Fi\
    leData\x12\x18\n\x07content\x18\x01\x20\x01(\x0cR\x07content\x12)\n\x04i\
    nfo\x18\x02\x20\x01(\x0b2\x15.kythe.proto.FileInfoR\x04info\x12\x18\n\
    \x07missing\x18\x03\x20\x01(\x08R\x07missing\"r\n\x11CompilationBundle\
    \x120\n\x04unit\x18\x01\x20\x01(\x0b2\x1c.kythe.proto.CompilationUnitR\
    \x04unit\x12+\n\x05files\x18\x02\x20\x03(\x0b2\x15.kythe.proto.FileDataR\
    \x05files\"\xaa\x01\n\x12IndexedCompilation\x120\n\x04unit\x18\x01\x20\
    \x01(\x0b2\x1c.kythe.proto.CompilationUnitR\x04unit\x12;\n\x05index\x18\
    \x02\x20\x01(\x0b2%.kythe.proto.IndexedCompilation.IndexR\x05index\x1a%\
    \n\x05Index\x12\x1c\n\trevisions\x18\x01\x20\x03(\tR\trevisionsBL\n\x1fc\
    om.google.devtools.kythe.protoZ&kythe.io/kythe/proto/analysis_go_proto\
    \xf8\x01\x01b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
