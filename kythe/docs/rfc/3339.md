# RFC: A(nother) Uniform Analyzer Interface for Kythe

https://github.com/kythe/kythe/issues/3306.md

This document describes an operational protocol to implement communication
between a Kythe analyzer and a driver program using a pair of reliable simplex
byte streams such as Unix pipes.

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
"SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be
interpreted as described in [RFC 2119](https://www.ietf.org/rfc/rfc2119.txt).

## Background and Motivation

The [Kythe](http://kythe.io) project supports a pluggable language-agnostic
ecosystem of tools for analyzing source code. Pluggability is provided by a
standard interface that a tool must implement in order to qualify as a Kythe
analyzer.

At a high level, an _analyzer_ is a program that consumes Kythe compilation
records as input, and emits `kythe.proto.Entry` protocol buffer messages as
output. However, the base definition of Kythe did not specify how this interface
is to be implemented concretely. That leaves the implementor a great deal of
flexibility, but makes it unnecessarily difficult to integrate analyzers that
are implemented in different languages.

The purpose of this proposal is to specify an explicit wire-level protocol for
communicating compilation records to, and collecting entries from, a Kythe
analyzer. Some important goals of this proposal are:

1.  To decouple analyzer implementations from the storage representations of
    compilation records and entry messages. This avoids the need to update
    analyzers when storage formats change, and makes it more practical to run
    analyzers in a sandbox.

2.  To make it easier to run analyzers as standalone tools, and reduce or
    eliminate the need to implement separate wrapper tools for testing vs.
    production.

3.  To reduce friction for analyzers written in languages that do not have good
    support for efficient manipulation of binary data, or which require FFI to
    get good performance.

## Common Terminology

-   A **compilation record** represents a single unit of analysis, corresponding
    to a single execution of a compiler tool in statically-typed languages. The
    record consists of a **compilation unit**, stored as a
    `kythe.proto.CompilationUnit` protocol buffer message, together with the
    contents of all the **required input** files mentioned by the compilation
    unit.

-   An **entry** is a datum representing a graph fragment defined by the
    [Kythe schema](https://kythe.io/docs/schema), as a `kythe.proto.Entry`
    protocol buffer message.

-   A **Kythe analyzer** is any program that consumes compilation records and
    emits Kythe entries. More generally, we may use the term **analyzer** to
    denote a program that consumes compilation records and emits _any_ kind of
    uniform data; this document is primarily concerned with Kythe analyzers, but
    is applicable to analyzers of all kinds.

-   A **driver** is a program that implements the server side of the interface
    defined in this document, providing access to the analysis environment for
    an analyzer program.

## Protocol Description

-   An analyzer communicates with a driver via a pair of reliable simplex byte
    streams such as Unix pipes, provided by the operating environment. An input
    stream delivers data from the driver to the analyzer, and an output stream
    receives output from the analyzer to the driver. In a POSIX environment,
    these streams correspond to stdin and stdout.

-   The data on each channel are partitioned into consecutive **frames**. Each
    frame consists of a length tag followed by a message body of that length.

    A **length tag** is a byte count _n_ encoded as a minimum-width decimal
    integer using the Unicode digits `0` (code 48) through `9` (code 57), and
    terminated by a newline (code 10). A **message body** is the sequence of _n_
    bytes immediately following the length tag.

    For example, a frame containing the message `foobar` is encoded as

        6    \n  f    o    o    b    a    r      -- text
        0x36 0xa 0x66 0x6f 0x6f 0x62 0x61 0x72   -- Unicode (hex)

-   Within this framing, the analyzer communicates with the driver using
    [JSON-RPC 2.0](http://www.jsonrpc.org/specification) requests and responses,
    as defined below. The analyzer is the JSON-RPC client, and the driver is the
    server.

    The server MUST support concurrent JSON-RPC requests from the analyzer. The
    server MUST support batch JSON-RPC requests from the analyzer.

-   Under certain circumstances, the analyzer process **must exit**. In a case
    where the analyzer process must exit, it MUST terminate within a grace
    period. If it does not, the operating environment SHOULD forcibly terminate
    the process (and may do so at any time after the grace period ends). The
    exit code of an analyzer process is ignored. The grace period is defined by
    the implementation, but must be at least 10 seconds.

-   If and after the analyzer closes the output stream, the analyzer process
    must exit.

-   If and after the driver closes the input stream, the analyzer process must
    exit.

-   A **corrupt frame** is one in which the length tag does not have the correct
    form. A frame is corrupt if the newline terminator is missing, the string
    preceding the newline terminator contains non-digits or is empty, or the
    stream ends before the specified number of bytes is delivered.

    If the analyzer receives a corrupt frame from the driver, it must exit. If
    the driver receives a corrupt frame from the analyzer, it must close the
    input stream (in which case the analyzer therefore must exit).

-   When an analyzer process terminates, the driver MUST consider any pending
    analysis requests to have failed, and thereafter the environment MAY retry
    analysis of the corresponding compilation records.

-   If the analyzer voluntarily (i.e. not at behest of the driver) exits
    succesfully (e.g. exit code of 0) with no outstanding analyses, the driver
    SHOULD cause a new instance of the analyzer to start. This is motivated by
    analyzers for which the best, or only, mechanism for clearing state is to
    restart.

### Messages

The following message structures are used by the protocol:

-   `InitRequest`

    ```
    {
      "protocol": <protocol>
      "outputEncoding": <output-encoding>
    }
    ```

-   `InitReply`

    ```
    {
      "protocol": <protocol>
    }
    ```

-   `AnalyzeRequest`

    ```
    {
      "types": <analysis-type-list>
    }
    ```

-   `AnalyzeReply`

    ```
    {
      "workingDir": <file-path>
      "inputs": <file-path-list>
      "arguments": <argument-list>
      "environment": <environment>
      "output": <file-path>
      "entryContext": <string>
      "outputKey": <file-path>
      "details": <details>
    }
    ```

-   `VNameRequest'
    ```
    {
	"path": <file-path>
	"signature": <string>
    }
    ```

-   `VNameReply`
    ```
    {
	"vname": <vname>
    }
    ```

-   `LogRequest`

    ```
    {
      "message": <diagnostic>
    }
    ```

The basic types referenced above are:

-   `<analysis-id>`: an integer ID assigned by the server (JSON: number).
-   `<bytes>`: a base64-encoded byte string (JSON: string).
-   `<diagnostic>`: a `kythe.proto.common.Diagnostic` message (JSON: object).
-   `<digest>`: a lower-case hex-coded SHA-256 digest (JSON: string).
-   `<file-path>`: a file path (JSON: string).
-   `<file-path-list>`: a list of `file-path` (JSON: list).
-   `<vname>`: a `kythe.proto.VName` message (JSON: object).
-   `<protocol>`: a protocol version label (JSON: string).
-   `<analysis-type-list>`: a list of an identifier for a specific type or
    types of analyses.
-   `<output-encoding>`: an identifier indicating how the output will be
    encoded, must be one of `json` or `protobuf` (JSON: string).

Where the description refers to a protocol buffer message, the message is
encoded using the canonical
[JSON mapping](https://developers.google.com/protocol-buffers/docs/proto3#json)
for the named message type.

#### analysis-type

Analysis types are described by precisely the same grammar as a
[kythe fact](https://kythe.io/docs/kythe-storage.html#_a_id_termfact_a_fact),
repeated here:

```
analysis-type =  "/" | 1*path
path          =  "/" word
word          =  1*{LETTER|DIGIT|PUNCT}
LETTER        =  // Unicode letter, category Lu, Ll, Lt, Lm, or Lo
DIGIT         =  // Unicode digit, category Nd
PUNCT         =  [-.@#$%&_+:()]
```
 
Analysis types whose leading segment is `/kythe` are reserved for use by
Kythe. An example analysis type might be `/kythe/index/java`, indicating the
Kythe indexer for Java.

### Methods

A driver defines the following JSON-RPC methods:

-   `init(InitRequest) → InitReply`

    The `init` method is a protocol handshake, and must be the first method
    called by the analyzer upon startup. The request specifies the protocol
    version understood by the analyzer. If the environment understands the
    requested version, it echoes the version in its reply.

    If any other method is called prior to a successful invocation of `init`, or
    if the environment doesn't recognize the protocol version requested, the
    environment will report ProtocolError and close the input channel.

    This document defines the protocol `"kythe1"`.

    Example:

        » {"jsonrpc":"2.0","id":1,"method":"init","params":{"protocol":"kythe1", "output-encoding":"json"}}
        « {"jsonrpc":"2.0","id":1,"result":{"protocol":"kythe1"}}

-   `analyze(AnalyzeRequest) → AnalyzeReply`

    Request a fresh compilation record from the environment, blocking until one
    is available. Once an analysis has started, it is designated as **pending**
    until the analyzer sends a `done` notification (see below). The driver MUST
    report ProtocolError and close the input channel if the analyzer issues an
    `analyze` request while another analysis is pending.
    
    The reply includes the input file(s) on which to begin analysis, as well as
    the output file to which to emit analysis output. It reflects some of the
    kythe.proto.CompilationUnit structure. The driver (and driver environment)
    MUST make contents available for each file referenced in the compilation
    record at the file system path specified in the compilation record.

    The output file should contain the content appropriate to the
    analysis-type, encoded as specified in the `InitRequest`. For Kythe index
    analyses, this would be `kythe.common.Entry` objects. Other analyzers might
    emit a "findings" structure.

    Note that contents need not be literally copied. An overlay filesystem,
    hardlinks, symlinks, or other may be used.

    Example:

        » {"jsonrpc":"2.0","id":2,"method":"analyze","params":{"types":["kythe/indexer/go"]}}
        « {"jsonrpc":"2.0","id":2","result":{"input":"path/to/main.go", "output":"path/to/output.json"}}

-   `vname(VNameRequest)`

    Requests the complete VName to emit for the specified path and signature.

-   `log(LogRequest)`

    A notification from the analyzer to the environment, containing a message
    string to be logged in association with the current analysis. The
    environment does not reply.

    Example:

        » {"jsonrpc":"2.0","method":"log","params":{"message":{...}}}

-   `done(LogRequest)`

    A notification from the analyzer to the environment, signifying that the
    analyzer has completed work on the current analysis. The environment
    does not reply. After receiving this notification, the driver SHOULD
    stop any virtualization of the filesystem corresponding to analysis input.

    Example:

        » {"jsonrpc":"2.0","method":"done","params":{"message":"success"}}

### Errors

In addition to the standard errors defined by JSON-RPC, this protocol defines
these errors:

-   `ProtocolError` (code: -1). Indicates a violation of the protocol.

## Input filesystem

This RFC essentially postulates that the driver presents the analyzer
a *limited* virtualization of a filesystem, specific to each
analysis. In the context of a single analysis:

-   For each file path occurring in the compilation record, the driver MUST 
    support `open()`, `read()` and `lseek()` (or equivalent) operations. The
    contents backing such operations MUST be precisely the contents specified
    in the compilation record. Other file operations MAY be supported.

-   For each directory implied by the file paths in the compilation record, the
    driver MAY support a subset of read-only directory operations, e.g. in order
    to provide directory listings via `readdir(3)` or equivalent.

-   For paths not occurring in the compilation record, the driver MAY
    fall back to the underlying host filesystem.

## Output

The output file MUST be treated as append-only by the analyzer, with no seek,
read or other operations permitted. Data MUST written to the output file based
on the encoding negotiated in the Init request/response.

-   For "json" encoding, the analyzer MUST write the output as
    [varint](https://developers.google.com/protocol-buffers/docs/encoding#varints)
    length-prefixed records.

-   For "protobuf" encoding, the analyzer MUST write the output as [delimited
    proto
    output](https://developers.google.com/protocol-buffers/docs/techniques#streaming)
    using varint length-prefixed records.



## Example Transcript

The following is an example transcript of an interaction between an analyzer and
its environment. The marker "»" denotes a request sent by the analyzer to the
environment; the marker "«" denotes a reply sent by the environment to the
analyzer. Lines prefixed with `--` are comments.

```
-- Protocol handshake.

» {"jsonrpc":"2.0", "id":1, "method":"init", "params":{"protocol":"kythe1","output-encoding":"protobuf"}}
« {"jsonrpc":"2.0", "id":1, "result":{"protocol":"kythe1"}}

-- Request an analysis task. The analyzer may process no more than one task
-- concurrently.

» {"jsonrpc":"2.0", "id":2, "method":"analysis", "params":{"types":["kythe/indexer/go"]}}
« {"jsonrpc":"2.0", "id":2, "result":{"inputs":["path/to/file1.go"], "output:"/tmp/0ABDEASF234.pb"}}

-- Do some work (output emitted to specified file, not here).

» {"jsonrpc":"2.0", "id":3, "method":"vname", "params":{"path":"path/to/corelib.go", "signature":"12345"}}
« {"jsonrpc":"2.0", "id":3, "result":{"corpus":"mylib", "root":"stdlib", "path":"path/to/corelib.go", "signature":"12345", "language":"go"}}

-- Emit some logs / diagnostics.

» {"jsonrpc":"2.0", "id":4, "method":"log", "params":{"message": "beep!"}}

-- Mark an analysis complete.

» {"jsonrpc":"2.0", "id":5, "method":"done"}

-- Request another analysis.
» {"jsonrpc":"2.0", "id":6, "method":"analysis", "params":{"types":["kythe/indexer/go"]}}
« {"jsonrpc":"2.0", "id":6, "result:"{"inputs":["path/to/file2.go"], output:"/tmp/8FED83928.out"}}

-- Do some more work.

-- Mark the second analysis complete.

» {"jsonrpc":"2.0", "id":7, "method":"done"}
```
